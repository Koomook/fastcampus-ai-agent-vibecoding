# Clip 1 발표 스크립트: 바이브코딩의 리스크를 낮추기 위한 feature 선정 방법

**발표 시간:** 5-7분
**발표자:** [이름]
**대상:** AI 에이전트 강의 수강생

---

## 🎬 오프닝 (30초)

안녕하세요. 오늘은 **"바이브코딩을 프로덕션에서 안전하게 사용하는 방법"**에 대해 이야기하겠습니다.

여러분, 혹시 이런 경험 있으신가요? Claude나 ChatGPT에게 코드를 맡겼는데...
- API 키가 그대로 노출되거나
- 이상한 버그가 잔뜩 생기거나
- 나중에 코드를 보니 도저히 이해할 수 없는 스파게티 코드가 되어있거나?

**이게 바로 바이브코딩의 딜레마입니다.**

오늘 Anthropic의 Erik Schultz가 실제로 **22,000줄의 코드를 Claude로 작성해서 프로덕션에 배포한 사례**를 통해, 어떻게 하면 바이브코딩을 안전하게 할 수 있는지 배워보겠습니다.

---

## 📊 문제 제기 (1분)

### 바이브코딩이란?

Andre Karpathy가 정의한 바이브코딩은 단순히 "AI가 코드를 많이 작성한다"가 아닙니다.

> **"코드가 존재한다는 사실조차 잊는다"**

말 그대로, 코드를 한 줄도 안 보고 AI에게 전부 맡기는 겁니다.

### 현실적인 문제

지금까지 성공한 바이브코딩 사례는 뭐가 있을까요?
- ✅ 간단한 게임
- ✅ 재미있는 사이드 프로젝트
- ✅ 프로토타입

반대로 실패한 사례는?
- ❌ 보안 취약점 대량 발생
- ❌ API 키 노출로 무제한 사용
- ❌ 구독 시스템 우회 가능

**문제는 명확합니다: 바이브코딩은 저위험 장난감 프로젝트에서만 성공했다는 점입니다.**

---

## 🚀 핵심 개념: 왜 바이브코딩을 배워야 하나? (1분)

그런데 왜 이걸 배워야 할까요?

**답은 지수적 성장(Exponential Growth)입니다.**

Erik Schultz가 발표한 통계를 보면:
- AI가 처리할 수 있는 작업 길이가 **7개월마다 2배씩** 증가
- 현재(2024-2025): 1시간 분량 → Cursor로 충분
- 1년 후(2026): 1일 분량 → 모든 코드 읽기 어려움
- 2년 후(2027): 1주일 분량 → **라인별 검토 불가능**

**컴파일러 비유를 들어볼까요?**

옛날 개발자들은 컴파일러가 만든 어셈블리 코드를 일일이 검토했습니다. "내가 작성한 어셈블리랑 다른데?"

하지만 지금은요? 어셈블리가 뭔지도 모르는 개발자들이 훌륭한 소프트웨어를 만듭니다.

**AI 코딩도 마찬가지입니다.**
- 우리는 코드를 잊게 될 것입니다
- 하지만 **제품은 절대 잊지 않을 것입니다**

---

## 🌿 핵심 전략: Leaf Nodes (2분)

그렇다면 어떻게 안전하게 바이브코딩을 할 수 있을까요?

### Leaf Nodes란?

**Leaf Nodes = 코드베이스에서 다른 코드가 의존하지 않는 말단 기능**

예를 들어:
- ✅ 대시보드 위젯
- ✅ 통계 차트
- ✅ PDF 리포트 생성
- ✅ 특정 페이지 UI

이런 것들은 **독립적**입니다. 다른 코드가 이것들에 의존하지 않죠.

반대로, 절대 바이브코딩하면 안 되는 것:
- ❌ 인증 시스템 (전체 앱이 의존)
- ❌ API Client (모든 요청이 사용)
- ❌ 데이터베이스 Layer (모든 데이터 접근)

### 왜 Leaf Nodes인가?

**Tech Debt(기술 부채) 때문입니다.**

| 코드 영역 | Tech Debt 발생 시 |
|----------|------------------|
| Core Architecture | 🚨 전체 시스템 마비 |
| Shared Libraries | ⚠️ 여러 기능에 버그 전파 |
| **Leaf Nodes** | ✅ **해당 기능만 영향** |

Erik Schultz는 이렇게 말합니다:
> "Tech debt는 검증하기 어렵다. 하지만 Leaf Nodes는 Tech debt가 있어도 다른 곳으로 전파되지 않는다."

---

## 💡 실제 사례: Anthropic의 22,000줄 PR (1.5분)

이제 실제 사례를 볼까요?

### 프로젝트 개요
- **대상:** 강화학습(RL) 코드베이스
- **규모:** 22,000줄 변경
- **결과:** 프로덕션 배포 성공
- **시간 절약:** 2주 → 1일 (14배 생산성)

### 4가지 성공 요인

**1. Claude의 PM이 되었다**
- 15-20분 동안 요구사항 수집
- 코드베이스 컨텍스트 제공
- 참고할 패턴 예시 제공

**2. Leaf Nodes에 집중**
- 대부분: Leaf Nodes → 바이브코딩
- 일부 핵심: 인간이 직접 검토

**3. 검증 가능하게 설계**
- 입력/출력이 명확
- End-to-End 테스트
- 스트레스 테스트

**4. 스트레스 테스트 실행**
- 장시간 실행 테스트
- 안정성 검증
- 성능 모니터링

### 결과

단순히 시간을 절약한 것만이 아닙니다.

> "이걸 할 수 있다는 걸 알고 나니, 생각하는 방식이 바뀌었습니다. 2주 걸릴 일이 하루면 된다는 걸 알면, 훨씬 큰 기능을 만들 수 있죠."

---

## ✅ 실전 체크리스트 (1분)

자, 그럼 여러분이 실전에서 사용할 수 있는 체크리스트입니다.

### Feature 선정할 때

```
✅ 바이브코딩 가능:
□ Leaf Node인가? (다른 코드가 의존하지 않는가?)
□ 변경 빈도가 낮은가?
□ Tech Debt가 격리 가능한가?
□ 입력/출력이 명확한가?
□ 테스트로 검증 가능한가?

❌ 바이브코딩 불가:
□ 핵심 아키텍처인가?
□ 보안/인증 시스템인가?
□ 결제/금융 로직인가?
□ 여러 기능이 의존하는가?
```

### 실습 예제

3개 Feature가 있다면:
1. **대시보드 통계 차트 추가** → ✅ Leaf Node, 바이브코딩 가능
2. **OAuth 2.0 추가** → ❌ 핵심 보안, 바이브코딩 불가
3. **PDF 리포트 생성** → ✅ Leaf Node, 바이브코딩 가능

---

## 🎯 클로징: 4가지 원칙 (30초)

마지막으로, **바이브코딩 in Production의 4가지 원칙**을 기억하세요:

```
1. 🎯 Be Claude's PM
   → AI에게 명확한 요구사항과 컨텍스트 제공

2. 🌿 Focus on Leaf Nodes
   → Tech Debt가 격리되는 영역에만 적용

3. ✅ Think About Verifiability
   → 코드를 읽지 않고도 검증 가능하도록 설계

4. 📈 Remember the Exponential
   → 1-2년 후, AI는 1주일 분량을 하루에 작성
```

---

## 💬 마무리 메시지 (30초)

여러분, 바이브코딩은 선택이 아닙니다.

지금 당장은 괜찮을 수 있습니다. Cursor로 1시간짜리 작업을 충분히 검토할 수 있으니까요.

하지만 **1-2년 후**에는?

AI가 1주일 분량의 코드를 작성할 때, 여러분이 모든 라인을 읽고 검토할 건가요?

**그때 가서 배우기엔 늦습니다.**

지금부터 Leaf Nodes 전략으로 안전하게 바이브코딩을 연습하세요.

그것이 여러분이 **지수적 성장의 혜택을 받을 수 있는 유일한 길**입니다.

감사합니다!

---

## 📌 Q&A 대비 답변

### Q1: "비개발자도 바이브코딩을 할 수 있나요?"

**A:** Erik Schultz는 명확히 말합니다: "비개발자가 처음부터 비즈니스를 만드는 건 위험합니다." 왜냐하면 **올바른 질문을 할 수 없기 때문**입니다. 바이브코딩은 Product Manager 역할을 하는 것이고, 그러려면 기본적인 기술 이해가 필요합니다.

### Q2: "Tech Debt를 어떻게 관리하나요?"

**A:** 현재로서는 Tech Debt를 자동으로 검증하는 방법이 없습니다. 그래서 **Leaf Nodes 전략**이 중요합니다. Tech Debt가 생겨도 다른 코드로 전파되지 않으니까요. 핵심 아키텍처는 여전히 인간이 직접 검토해야 합니다.

### Q3: "Claude Code vs Cursor, 어떤 걸 쓰나요?"

**A:** Erik은 둘 다 사용합니다. 보통:
- **Claude Code**: 큰 Feature 개발 (15-20분 요구사항 수집 후 자율 실행)
- **Cursor**: 작은 수정이나 특정 라인 변경
- 코드 검토는 VS Code에서 진행

### Q4: "실패하면 어떻게 하나요?"

**A:** Leaf Nodes이기 때문에 **전체를 새로 작성해도 됩니다**. 다른 코드에 영향이 없으니까요. 이것이 Leaf Nodes의 핵심 장점입니다.

---

## 🎤 발표 팁

### 타이밍 배분
- 오프닝: 30초
- 문제 제기: 1분
- 지수적 성장: 1분
- Leaf Nodes: 2분
- 실제 사례: 1.5분
- 체크리스트: 1분
- 마무리: 1분
- **총 시간: 약 7분**

### 강조할 포인트
1. **"22,000줄"** - 숫자를 강조하여 임팩트 전달
2. **"7개월마다 2배"** - 지수적 성장의 무서움
3. **"2주 → 1일"** - 14배 생산성 향상
4. **"코드를 잊지만 제품은 잊지 않는다"** - 핵심 메시지

### 시각 자료 활용
- 슬라이드에 Mermaid 다이어그램 3개 포함 권장:
  1. 코드베이스 의존성 트리 (Leaf Nodes 시각화)
  2. 지수적 성장 타임라인
  3. Feature 선정 플로우차트

### 청중 참여
"여러분, 혹시 이런 경험 있으신가요?" - 손들기 유도
"3개 Feature 중 어떤 게 Leaf Node일까요?" - 퀴즈 형식
